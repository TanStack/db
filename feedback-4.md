- High – `queueStrategy` now runs every transaction’s `commit()` a second time. `createSerializedMutations` already calls `transaction.commit()` inside the scheduled callback (`packages/db/src/serialized-mutations.ts:101-127`), but the queue worker awaits `transaction.commit()` again (`packages/db/src/strategies/queueStrategy.ts:61-66`). The second call happens while the transaction state is `persisting`, so the queue immediately hits `TransactionNotPendingCommitError` and aborts the item. The queue should wait on `transaction.isPersisted.promise` (or let the strategy callback return the commit promise) instead of invoking `commit()` itself.

- High – `cleanup()` can throw and/or corrupt completed transactions. If the active commit finishes right before cleanup runs, the transaction is already in the `completed` state when we call `executingTransaction.rollback()` (`packages/db/src/serialized-mutations.ts:149-152`), so `TransactionAlreadyCompletedRollbackError` bubbles out of cleanup. Even when the commit is still in flight, forcing a rollback races with the resolver `then` handlers. Please guard the rollback with a state check (or await `isPersisted.promise`) so teardown stays safe.

- High – Strategies that drop callbacks leave returned transactions pending forever. We only remove/rollback entries inside the strategy callback (`packages/db/src/serialized-mutations.ts:101-113`), but Pacer’s debouncer/throttler simply skip calling `fn` when `trailing` is disabled (see `packages/db/src/strategies/debounceStrategy.ts:31-40`). In that configuration every suppressed `mutate` returns a transaction whose `isPersisted.promise` never settles unless another call eventually fires or cleanup runs. We need to settle those transactions immediately when the strategy decides not to run them (e.g. cancel/rollback on reschedule, or reuse a single transaction per manager).
