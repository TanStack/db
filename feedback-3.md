- High – Trailing strategies leave earlier transactions permanently pending. Each `mutate` call in `createSerializedTransaction` creates a fresh transaction and immediately returns it (`packages/db/src/serialized-transaction.ts:80-103`), but the debouncer/throttler only runs the _latest_ scheduled callback (`packages/db/src/strategies/debounceStrategy.ts:31-45`, `packages/db/src/strategies/throttleStrategy.ts:45-58`). When a later call supersedes an earlier one, the earlier transaction never commits or rolls back, so `tx.isPersisted.promise` never resolves and the transaction stays in the global pending list. We need to either reuse a single transaction per manager or explicitly cancel/rollback superseded transactions whenever a strategy drops them.

- High – `cleanup()` can leave optimistic mutations stuck in a pending transaction. If the consumer unmounts while a trailing debounce/throttle call is waiting, `cleanup()` only cancels the strategy (`packages/db/src/serialized-transaction.ts:109-111`). The transaction we already created remains `pending`, its optimistic changes stay applied, and `isPersisted.promise` never settles. `cleanup()` should flush or rollback any in-flight transaction before returning.

- High – The queue strategy does not serialize commits. `queueStrategy` wires `Queuer`’s synchronous `onGetNextItem` callback directly to `transaction.commit()` (`packages/db/src/strategies/queueStrategy.ts:48-65`), but `Queuer` keeps pulling items without waiting for that callback to finish. As a result, every queued transaction starts committing immediately and we lose sequencing guarantees. Switching to `AsyncQueuer` (or awaiting the `commit()` promise before processing the next item) should fix this.
